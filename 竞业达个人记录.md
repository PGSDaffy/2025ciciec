# 马骁飞个人记录
## x月xx日
### 计划目标
### 具体todo
### 过程记录
### 遭遇问题
### 备注

## 3月26日
### 计划目标
实现运行第一个c程序
### 具体todo
 - [x]  整理所有用到的指令（搞清楚伪指令）
 - [x]  重新跟讲义读一下执行的代码，将不会的内容先记下来
 - [x] 搞清楚nemu内置的指令
 - [x] 尝试添加指令
### 过程记录
 1. 反汇编结果：
基础指令：`auipc/addi/jal/sw`
伪指令：`li(addi+lui)/ret(jalr)/mv(addi,rs)/j(jal)`
为了尝试了解指令，rtfm。（阅读了rvreader的第二章（rv32i基础整数指令集），在过程中了解了条件分支（跳转与预测）/立即数扩展的基本概念，寄存器和缓存，内存。硬盘在于cpu进行数据交互时的地位。根据反汇编结果大概了解了c程序是如何以指令执行的。
2. 阅读nemu：
运行nemu之后输入的`c`或`si`都是在调用`cpu_exec(n)`去执行n条指令，而`cpu_exec`则通过调用`execute`来执行，除去其中的`trace`和`difftest`相关代码，执行部分调用了`exec_once`。`exec_once`两行分别调用了`inst_fetch`和`decode_exec`进行取指，译码和执行。前者就是调用了一些仿存函数读出指令，后者通过宏定义`INSTPART`来处理指令字符串，`decode_operand`根据不同的指令格式（不全）来对操作数和立即数进行读存，关于指令具体执行，就是通过c代码来模拟rtl对数据的处理。
3. 添加指令：
了解清楚逻辑之后，读`INSTPAT`中自带的一些指令：`auipc``lbu``sb``ebreak``inv`搞明白了应该如何添加，就是在`operand`中加字符处理的函数，并在`INSTPAT`里面添加对应的指令即可。
```c
INSTPAT("??????? ????? ????? 010 ????? 01000 11", sw, S, Mw(src1 + imm, 4, src2)); // 向内存中写入

INSTPAT("??????? ????? ????? 000 ????? 00100 11", addi, I, R(rd) = src1 + imm); // addi指令

INSTPAT("??????? ????? ????? ??? ????? 11011 11", jal, J, R(rd) = s->pc + 4; s->dnpc += imm - 4;); // jal指令

INSTPAT("??????? ????? ????? 000 ????? 11001 11", ret, I, R(rd) = s->pc + 4; s->dnpc = (src1 + imm) & ~1); // jalr(ret)指令
```
4.执行结果：
```bash
[src/cpu/cpu-exec.c:120 cpu_exec] nemu: HIT GOOD TRAP at pc = 0x8000000c
[src/cpu/cpu-exec.c:88 statistic] host time spent = 4,112 us
[src/cpu/cpu-exec.c:89 statistic] total guest instructions = 4
[src/cpu/cpu-exec.c:90 statistic] simulation frequency = 972 inst/s
```

### 遭遇问题
### 备注
卡了好久读不明白inst.c里面的宏，ds友情帮助下一知半解能跑了，结果好像ysyx视频号里的代码导读直接讲了，被自己气笑了。

## 3月27日
### 计划目标
继续添加指令实现更多的程序，阅读am内容的讲义
### 具体todo
- [ ] 继续往里加指令，可能会有难以模拟的rtl操作，需要想别的办法。
- [ ] （可选）可以看一下
### 过程记录
### 遭遇问题
### 备注
<!--stackedit_data:
eyJoaXN0b3J5IjpbMTExMjIwOTM3NywtMTQ4ODA5MjE3OSwxMT
Q5MTE4MzM2LDExOTA5MjQ3NjYsLTY3NjAyNzIwNywxMTI0NTg1
MDgyLDEyMzgzODQ2MjksLTQ1MTUyMjUwMSwtMTY3NjgzNTM1Ny
wtNzY2NzE2NTUyXX0=
-->